---
name: Process URLs
description: Process presigned URLs to extract specific file URLs

outputs:
  filename:
    description: The filename of the common tar.gz file
    value: ${{ steps.process_urls.outputs.filename }}
  flat_build_url:
    description: Pre-signed URL for the common tar.gz file
    value: ${{ steps.process_urls.outputs.flat_build_url }}

runs:
  using: "composite"
  steps:
    # Normalize ARTIFACT_KEY to basename without .yml (so we can use it in artifact name)
    - name: Normalize ARTIFACT_KEY
      shell: bash
      run: |
        set -e
        # ARTIFACT_KEY may be a path like meta-audioreach/ci/rb3gen2-core-kit.yml
        base="$(basename "${ARTIFACT_KEY}" .yml)"
        echo "ARTIFACT_KEY_BASENAME=${base}" >> "$GITHUB_ENV"
        echo "Normalized ARTIFACT_KEY to: ${base}"

    # Only download urls for flat_build ('flat_build' url is used in test job)
    - name: Download Presigned URL list
      uses: actions/download-artifact@v4
      with:
        # Use normalized basename so it matches the artifact name produced during build
        name: ${{ env.MACHINE }}_flat_build_${{ env.ARTIFACT_KEY_BASENAME }}_presigned_urls.json
        path: ${{ github.workspace }}

    # Extract the filename and url from the json file
    - name: Process Presigned URLs
      id: process_urls
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const p = require('path');
          // NOTE: do not redeclare 'core'; it's provided by github-script v7

          const machine = process.env.MACHINE;

          // ARTIFACT_KEY may be a full path; normalize to basename without .yml
          const artifactKeyRaw = process.env.ARTIFACT_KEY || '';
          const artifactKey = p.basename(artifactKeyRaw, '.yml');

          const jsonName = `${machine}_flat_build_${artifactKey}_presigned_urls.json`;
          const filePath = p.join(process.env.GITHUB_WORKSPACE, jsonName);

          if (fs.existsSync(filePath)) {
            console.log(`Found presigned URLs file: ${filePath}`);
          } else {
            core.setFailed(`File not found: ${filePath}`);
            return;
          }

          // Read the JSON file
          const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));

          // Initialize outputs
          let flat_build_url = "";
          let flat_build_vision = "";
          let script_file_url = "";
          let filename = "";

          // Helper: find URL by filename (kept from your original intent)
          function findUrlByFilename(name) {
            for (const [path, url] of Object.entries(data)) {
              if (path.endsWith(name)) {
                return url;
              }
            }
            return null;
          }

          // Find URLs for specific files
          for (const [path, url] of Object.entries(data)) {
            if (path.endsWith('.tar.gz')) {
              if (path.includes('vision')) {
                flat_build_vision = url; // vision tarball
              } else {
                flat_build_url = url;     // common tarball
                filename = path;          // keep full path string; downstream can basename if needed
              }
            } else if (path.endsWith('.sh')) {
              script_file_url = url;      // optional SDK installer URL if present
            }
          }

          // Set outputs
          core.setOutput('flat_build_vision', flat_build_vision);
          core.setOutput('script_file_url', script_file_url);
          core.setOutput('flat_build_url', flat_build_url);
          core.setOutput('filename', filename);